#==================================================================================================
# ZetaCalcIntegrals.R
#
# Y:\proj\CFWI_WetlandStress\Update2018\ZetaCalcIntegrals.R
# or	\\ad.sfwmd.gov\dfsroot\data\wsd\SUP\proj\CFWI_WetlandStress\Update2018\ZetaCalcIntegrals.R
#==================================================================================================
#==================================================================================================
# Evaluate Wetland Stress criteria to compute Zetas
#		using Integral functions for Probable Change in Stressed Acres
#
# Created by Kevin A. Rodberg - February 2019
#
#		zetaModels generated by ZetaCalcIntegrals.R (this script) are used
#		by P80headDiffProbabilities.R to create cell by cell probability matrix of change in
#		wetland stress and calculates the probable change in acres
#		by wetland type (ridge or plain) from stressed to unstressed and from unstressed to stressed.
#==================================================================================================

#--
#   package management:
#     provide automated means for first time use of script to automatically 
#	  install any new packages required for this code, with library calls 
#	  wrapped in a for loop.
#--
pkgChecker <- function(x){
  for( i in x ){
    if( ! require( i , character.only = TRUE ) ){
      install.packages( i , dependencies = TRUE )
      require( i , character.only = TRUE )
    }
  }
}

list.of.pkgs <-  c("readr","dplyr","zoo","ggplot2", "reshape2", "data.table",
                   "future","listenv","readxl","purrr","e1071" ,"rcompanion","tictoc")

suppressMessages(pkgChecker(list.of.pkgs))

#==================================================================================================
# Read preprocessed P80 data sets
#==================================================================================================
workdir= "Y:/proj/CFWI_WetlandStress/Update2018"
setwd(workdir)

SFWMD_P80b <- read_csv("./SFWMD/SFWMD_P80.csv")
SWFWMD_P80b <- read_csv("./SWFWMD/SWFWMD_P80.csv")
SJRWMD_P80b <- read_csv("./SJRWMD/SJRWMD_P80.csv")
AllP80 <-bind_rows(SFWMD_P80b,SWFWMD_P80b,SJRWMD_P80b)

EMT_ID <- read_csv("EMT_ID.csv")
AllP80 <-merge(EMT_ID,AllP80)
write.csv(AllP80,file='AllP80.csv',row.names=FALSE)

Class1Wetlands <- read_excel("Class 1 Wetland Info for Analysis ALLv1.xlsx", na = "NA")
Class1P80 <-merge(Class1Wetlands,AllP80, by.x='CFCA/EMT ID', by.y='EMT_ID')    
# Remove redundant 2006-2017_P80
Class1P80$`2006-2017_P80.y`<-NULL
names(Class1P80)[names(Class1P80)=='2006-2017_P80.x']<-"2006-2017_P80"
names(Class1P80)

makeQQplots <- function(oneTest, ranks, stress, phys) {
  filename = paste0('QQplot',stress,phys,ranks, '.png')
  png(filename)
  qqnorm(oneTest[,2],
         main= paste("Class 1 ",phys, " Wetlands",stress,'\n', ranks, '\n',
                     format(Sys.time(), "%a %b %d %X %Y")))
  qqline(oneTest[,2],col=2,qtype=2)
  dev.off()  
} 

#==================================================================================================
# Calculate Shapiro Wilkes
#==================================================================================================
thetas = data.frame()
strStr <- "Stress Status in 2018"
physStr <- "Physiographic Region"

physVec <-c("Plain","Ridge")
stressVec <- c("Stressed","Not Stressed")
#ranks = "2007-2017_P80"
# ranks = "2008-2017_P80"
ranks = "2009-2017_P80"
# ranks = "2010-2017_P80"
rankVec <- c( "2006-2017_P80","2007-2017_P80","2008-2017_P80","2009-2017_P80","2010-2017_P80" )
for (ranks in rankVec) {
  theta = Class1P80$"Edge Reference Elevation (ft NAVD 88)" - Class1P80[,ranks]
  thetas = rbind(thetas,cbind.data.frame(EMT_ID=Class1P80$`CFCA/EMT ID`, 
                                         rank=ranks,theta=as.numeric(theta)))
}
thetas <- merge(thetas,Class1P80[,c(1,3,6,7)], by.x='EMT_ID', by.y = "CFCA/EMT ID")

names(thetas)[names(thetas) == "Stress Status in 2018"] <-"Stress"
names(thetas)[names(thetas) == "Physiographic Region"] <-"phys"
wideTheta <- dcast(thetas,EMT_ID~rank,value.var='theta',mean)
thetaEval <- merge(wideTheta,Class1P80[,c(1,3,6,7,12)], by.x='EMT_ID', by.y = "CFCA/EMT ID")

for (ranks in rankVec) {
  for (phys in physVec) {
    for (stress in stressVec) {
      oneTest <- thetaEval[thetaEval$'Stress Status in 2018' == stress &
                             thetaEval$'Physiographic Region' == phys ,
                           c('EMT_ID',ranks,'Stress Status in 2018','Physiographic Region')]
      names(oneTest)[names(oneTest) == ranks] <- "theta"
      names(oneTest)[names(oneTest) == 'Stress Status in 2018'] <-"stress"
      names(oneTest)[names(oneTest) == "Physiographic Region"] <-"phys"
      makeQQplots(oneTest, ranks, stress, phys)
      swTest <- shapiro.test(oneTest$theta)
      cat (paste0('"shapiro.test for ","',stress,'","',phys,'", "',ranks,'",'))
	    cat(paste0(swTest$statistic, '  ', swTest$p.value, '\n'))
	  }
  }
}

#==================================================================================================
# Calculate thetas
#==================================================================================================
#rankVec <- c( "2007-2017_P80" )
# rankVec <- c( "2008-2017_P80" )
rankVec <- c( "2009-2017_P80" )
# rankVec <- c( "2010-2017_P80" )
thetas = data.frame()

for (ranks in rankVec) {
  theta = Class1P80$"Edge Reference Elevation (ft NAVD 88)" - Class1P80[,ranks]
  thetas = rbind(thetas,cbind.data.frame(EMT_ID=Class1P80$'CFCA/EMT ID', rank=ranks,theta=as.numeric(theta)))
}
thetas <- merge(thetas,Class1P80[,c(1,3,6,7)], by.x='EMT_ID', by.y = "CFCA/EMT ID")

names(thetas)[names(thetas) == strStr] <-"Stress"
names(thetas)[names(thetas) == physStr] <-"phys"

#==================================================================================================
# Fs and Fu are fraction of stressed wetlands and unstressed wetlands		Equations: 10 & 11
#==================================================================================================
thetas$Fu = NA
thetas$Fs = NA
thetas$mean = NA
thetas$sd = NA

for (phys in physVec) {
  
  #==================================================================================================
  # identify number of stressed vs unstressed and total for each physiographic type  
  #==================================================================================================
  stressKnt <- nrow(thetas[thetas$phys== phys 
                           & thetas$Stress == "Stressed",])
  UstressKnt <- nrow(thetas[thetas$phys== phys 
                            & thetas$Stress == "Not Stressed",])
  allKnt <- nrow(thetas[thetas$phys== phys ,])
  
  #==================================================================================================
  # Fs and Fu are fraction of stressed wetlands and unstressed wetlands		Equations: 10 & 11
  #==================================================================================================
  thetas[thetas$phys==phys,]$Fs <- stressKnt/allKnt
  thetas[thetas$phys==phys,]$Fu <- UstressKnt/allKnt
}
#==================================================================================================
#          phys   Urban       DisSim  SHA    sf_us  sf_su SFus  SFsu
#          ------ ----------  ------  -----  -----  ----- ----- -----
# class 1                                                 1.000 1.000
# class 2                                                 1.000 1.000
# Class 3  Plain	low	        0.694	  0.82	 0.824	0.176	0.469	0.100
# Class 3  Plain	Mod & High	0.616	  0.581	 0.824	0.176	0.295	0.063
# Class 3  Ridge	All	        0.671	  1	     0.581	0.419	0.390	0.281

#==================================================================================================
# transform data by subsets using:
#     phys- Physiographic Region (Ridge or Plain)
#     stress- Wetland Stress Status in 2018, 
#==================================================================================================
rankVec <- c( "2006-2017_P80","2007-2017_P80","2008-2017_P80","2009-2017_P80","2010-2017_P80" )
for (phys in physVec) {
  for (stress in stressVec) {
    #----------------------------------------------------------------------------------------
    # mean and sd are calculated for use with a probability density function for the selected
    # physiographic region type and initial Stress Status in 2018
    #----------------------------------------------------------------------------------------
    thetas[thetas$Stress == stress & thetas$phys == phys, ]$mean <-
      mean(thetas[thetas$Stress == stress & thetas$phys == phys, ]$theta)
    thetas[thetas$Stress == stress & thetas$phys == phys, ]$sd <-
      sd(thetas[thetas$Stress == stress & thetas$phys == phys, ]$theta)
  }
}
thetaInterval = .1
# thetaSeq<-seq(-20,25,thetaInterval)
# deltas <- seq(-15, 15,thetaInterval)
thetaSeq<-seq(-25,25,thetaInterval)
deltas <- seq(-20, 15,thetaInterval)

Plain<- as.data.frame(thetaSeq)
names(Plain) <-c('theta')
newColumns <-c('phys','Ppu','Ps','Pu','Pps','PpAll','PsiU','PsiS')
Plain[newColumns]<-0.0
Plain$phys <- "Plain"

Ridge<- as.data.frame(thetaSeq)
names(Ridge) <-c('theta')
Ridge[newColumns]<-0.0
Ridge$phys <- "Ridge"

Wetlands <-rbind(Plain,Ridge)

#==================================================================================================
# dnorm function returns probability from density function at each theta value  Equations: 12 & 13
#==================================================================================================
for (phys in physVec) {
  if (phys == 'Plain') {
    Mean <- max(thetas[thetas$Stress =="Stressed" & thetas$phys==phys,]$mean)
    SD   <- max(thetas[thetas$Stress =="Stressed" & thetas$phys==phys,]$sd)
    # 2014 values: Mean <- 5.18 SD <- 1.75 vs 2019 values:
    cat(paste("Stressed",phys,'Mean=',round(Mean,2),'StdDev=',round(SD,4)),'\n')
    Wetlands[Wetlands$phys == phys,]$Ps <- dnorm(Wetlands[Wetlands$phys == phys,]$theta, Mean, SD)
    
    Mean <- max(thetas[thetas$Stress =="Not Stressed" & thetas$phys==phys,]$mean)
    SD   <- max(thetas[thetas$Stress =="Not Stressed" & thetas$phys==phys,]$sd)
    # 2014 values: Mean <- 2.73 SD <- 0.95 vs 2019 values:
    cat(paste("Not Stressed",phys,'Mean=',round(Mean,2),'StdDev=',round(SD,4)),'\n')
    Wetlands[Wetlands$phys == phys,]$Pu <- dnorm((Wetlands[Wetlands$phys == phys,]$theta), Mean, SD)
  }
  else if (phys == 'Ridge')
  {
    Mean <- max(thetas[thetas$Stress =="Stressed" & thetas$phys==phys,]$mean)
    SD   <- max(thetas[thetas$Stress =="Stressed" & thetas$phys==phys,]$sd)
    # 2014 values: Mean <- 7.86  SD <- 2.55 vs 2019 values:
    cat(paste("Stressed",phys,'Mean=',round(Mean,2),'StdDev=',round(SD,4)),'\n')
    Wetlands[Wetlands$phys == phys,]$Ps <- dnorm(Wetlands[Wetlands$phys == phys,]$theta,Mean, SD)

    Mean <- max(thetas[thetas$Stress =="Not Stressed" & thetas$phys==phys,]$mean)
    SD   <- max(thetas[thetas$Stress =="Not Stressed" & thetas$phys==phys,]$sd)
    # 2014 values:  Mean <- 3.42  SD <- 1.57 vs 2019 values:
    cat(paste("Not Stressed",phys,'Mean=',round(Mean,2),'StdDev=',round(SD,4)),'\n')
    Wetlands[Wetlands$phys == phys,]$Pu <- dnorm(Wetlands[Wetlands$phys == phys,]$theta,Mean, SD)
  }
  
  #================================================================================================
  # Pps and Ppu are Population-weighted contributions of stress and unstress
  # wetlands to the total population probability density of all wetlands at 
  # each wetland hydrologic index (theta)                                 Equations: 14 & 15
  #================================================================================================
  Wetlands[Wetlands$phys == phys,]$Ppu <-
    Wetlands[Wetlands$phys == phys,]$Pu*max(thetas[thetas$phys==phys,]$Fu)
  Wetlands[Wetlands$phys == phys,]$Pps <-
    Wetlands[Wetlands$phys == phys,]$Ps*max(thetas[thetas$phys==phys,]$Fs)

  Wetlands[Wetlands$phys == phys,]$PpAll <-
    Wetlands[Wetlands$phys == phys,]$Ppu + Wetlands[Wetlands$phys == phys,]$Pps    
  #================================================================================================
  # PsiU and PsiS Population-weighted Cumulative Probability             Equation 17 & 18
  #================================================================================================
  Wetlands[Wetlands$phys == phys,]$PsiU <- 
    Wetlands[Wetlands$phys == phys,]$Ppu /Wetlands[Wetlands$phys == phys,]$PpAll
  Wetlands[Wetlands$phys == phys,]$PsiS <- 
    Wetlands[Wetlands$phys == phys,]$Pps /Wetlands[Wetlands$phys == phys,]$PpAll
}

write.csv(file='h:/Wetlands.csv',Wetlands)

#==================================================================================================
#   Returns stress appropriate PsiValue lookup from Wetlands Table 
#   using theta and final theta (or theta+delta)
#
#   type is not key, but used to subset data enable better performance
#   with multiple processors
#==================================================================================================
PsiVals <- function(type, status, hydIndex) {
  val <- round(hydIndex,2)
  if (status == 'Not Stressed' & !is.na(val)) {
    retVal<-(Wetlands[Wetlands$phys == type &
                        val == round(Wetlands[Wetlands$phys == type,]$theta, 2), ]$PsiU)
  }  else if (status == 'Stressed' & !is.na(val)) {
    retVal<-(Wetlands[Wetlands$phys == type &
                        val == round(Wetlands[Wetlands$phys == type,]$theta, 2),]$PsiS)
  }  else  {
    retVal<-NA
  }
}

#----------------------------------------------------------------------------
#   Vectorize function to work with dataframes input
#----------------------------------------------------------------------------
vPsiVals <- Vectorize(PsiVals)

#----------------------------------------------------------------------------
# Function used to calculate zetas 
#----------------------------------------------------------------------------
makeZetas <- function(phys,stress,deltas,thetaSeq) {
  z = matrix(NA,length(thetaSeq),1+length(deltas))
  z[,1] <- vdf[,1]
  for (i in seq(2,1+length(deltas))){
    psiTheta2 <-unname(unlist(vPsiVals(phys,stress,vdf[,i])))
    psiTheta1 <-unname(vPsiVals(phys,stress,vdf[,1]))
    z[,i] = 1 -   ( psiTheta2/psiTheta1)
    z[is.nan(z[,i]) ,i] <- NA
    z[z[,i]<0,i] <- 0
    z[z[,i]>1,i] <- NA
  }

  StressZetas<- as.data.frame(cbind(phys,stress,z,
                                    Wetlands[Wetlands$phys==phys,]$Ps,
                                    Wetlands[Wetlands$phys==phys,]$Pu))
  names(StressZetas) <- c("phys","stress","theta",deltas,"Ps","Pu")
  cat(paste('Zetas Calculated for',stress, phys,'\n'))
  return(StressZetas)
}
#---
# Define matrix/dataframe for intial and possible thetas
#---
vdf = c()
for (x in thetaSeq) {
  possibleThetas<- deltas+x
  vdf<-c(vdf,possibleThetas)
}

dim(vdf)<-c(length(deltas),length(thetaSeq))
vdf <- t(vdf)
vdf[vdf< min(thetaSeq)]<-NA
vdf[vdf> max(thetaSeq)]<-NA

# Add theta column to beginning 
vdf <-cbind(Wetlands[1:length(thetaSeq),]$theta,vdf)

physVec = c('Ridge','Plain')
stressVec = c('Not Stressed','Stressed')
ix = 0

plan(multiprocess)
data <- listenv()
#----------------------------------------------------------------------------
#   Create zetas using multiprocessing functions
#----------------------------------------------------------------------------
tic("Calculate Zetas")
for (phys in physVec){
  for (stress in stressVec){
    cat(paste(phys, stress, '\n'))
    ix = ix + 1
    data[[ix]] %<-% makeZetas(phys,stress,deltas,thetaSeq)
  }
}
xdata <- as.list(data)
zetas<- do.call(rbind,xdata)
zetaMelt <- melt(zetas,id=c("phys","stress","theta","Ps","Pu"),na.rm=T)
zetaMelt <-transform(zetaMelt, theta = as.numeric(as.character(theta)))
zetaMelt <-transform(zetaMelt, delta = as.numeric(as.character(variable)))
zetaMelt <-transform(zetaMelt, value = as.numeric(value))
zetaMelt <-transform(zetaMelt, Ps = as.numeric(as.character(Ps)))
zetaMelt <-transform(zetaMelt, Pu = as.numeric(as.character(Pu)))
#----------------------------------------------------------------------------
# calculate series of ittle zetas values for Big Zetas
#   for population-weighted average probability of change in stress              Equation 26 & 27
#----------------------------------------------------------------------------
zetaMelt$ZetaSU <- NA
zetaMelt[zetaMelt$stress == 'Stressed',]$ZetaSU<- thetaInterval*
  zetaMelt[zetaMelt$stress == 'Stressed',]$value * 
  zetaMelt[zetaMelt$stress == 'Stressed',]$Ps

zetaMelt$ZetaUS <- NA
zetaMelt[zetaMelt$stress == 'Not Stressed',]$ZetaUS<- thetaInterval*
  zetaMelt[zetaMelt$stress == 'Not Stressed',]$value * 
  zetaMelt[zetaMelt$stress == 'Not Stressed',]$Pu

toc()

#----------------------------------------------------------------------------
# Calculate Probability of Change as a function of delta theta
#   Big Z for Not Stressed Ridge and Plain
#----------------------------------------------------------------------------
BigZ<-aggregate(zetaMelt[zetaMelt$stress=='Not Stressed',]$ZetaUS, 
                         list(delta=zetaMelt[zetaMelt$stress=='Not Stressed',]$delta,
                              phys = zetaMelt[zetaMelt$stress=='Not Stressed',]$phys,
                              stress = zetaMelt[zetaMelt$stress=='Not Stressed',]$stress
                              ),sum, na.rm=T)

ZRPu_sNeg <- lm(x ~ poly(delta,9),data=BigZ[BigZ$phys=='Ridge' & BigZ$delta <= 0,])
ZRPu_sPos <- lm(x ~ poly(delta,9),data=BigZ[BigZ$phys=='Ridge' & BigZ$delta >= 0,])
ZPPu_sNeg <- lm(x ~ poly(delta,10),data=BigZ[BigZ$phys=='Plain' & BigZ$delta <= 0,])
# ZPPu_sNeg <- lm(x ~ poly(delta,9),data=BigZ[BigZ$phys=='Plain' & BigZ$delta <= 0,])
ZPPu_sPos <- lm(x ~ poly(delta,9),data=BigZ[BigZ$phys=='Plain' & BigZ$delta >= 0,])

polynomData <-NULL

#----------------------------------------------------------------------------
# Calculate probability change curves for positive and negative delta theta 
#   for initially unstressed Plains wetlands
#----------------------------------------------------------------------------
x <-data.frame(delta=(seq(min(BigZ$delta),0, .01)))
x$pred1 <- predict(ZRPu_sNeg,x)
newdata <-data.frame(delta=(seq(0,max(BigZ$delta), .01)))
newdata$pred1 <- predict(ZRPu_sPos,newdata)
newdata <-rbind(x,newdata)
polynomData <-newdata
setnames(polynomData, "pred1", "ZRPu")
#----------------------------------------------------------------------------
#   ...And for initially unstressed Ridge wetlands
#----------------------------------------------------------------------------
x <-data.frame(delta=(seq(min(BigZ$delta),0, .01)))
x$pred1 <- predict(ZPPu_sNeg,x)
newdata <-data.frame(delta=(seq(0,max(BigZ$delta), .01)))
newdata$pred1 <- predict(ZPPu_sPos,newdata)
newdata <-rbind(x,newdata)
polynomData<- merge(polynomData,newdata)
setnames(polynomData, "pred1", "ZPPu")

#----------------------------------------------------------------------------
# Calculate Probability of Change as a function of delta theta
#   Big Z for Stressed Ridge and Plain
#----------------------------------------------------------------------------
BigZ<-aggregate(zetaMelt[zetaMelt$stress=='Stressed',]$ZetaSU, 
                         list(delta=zetaMelt[zetaMelt$stress=='Stressed',]$delta,
                              phys = zetaMelt[zetaMelt$stress=='Stressed',]$phys,
                              stress = zetaMelt[zetaMelt$stress=='Stressed',]$stress
                         ),sum, na.rm=T)
ZRPs_uNeg <- lm(x ~ poly(delta,9),data=BigZ[BigZ$phys=='Ridge' & BigZ$delta <= 0,])
ZRPs_uPos <- lm(x ~ poly(delta,9),data=BigZ[BigZ$phys=='Ridge' & BigZ$delta >= 0,])
ZPPs_uNeg <- lm(x ~ poly(delta,10),data=BigZ[BigZ$phys=='Plain' & BigZ$delta <= 0,])
# ZPPs_uNeg <- lm(x ~ poly(delta,9),data=BigZ[BigZ$phys=='Plain' & BigZ$delta <= 0,])
ZPPs_uPos <- lm(x ~ poly(delta,9),data=BigZ[BigZ$phys=='Plain' & BigZ$delta >= 0,])

#----------------------------------------------------------------------------
# Calculate probability change curves for positive and negative delta theta 
#   for initially stressed Plains wetlands
#----------------------------------------------------------------------------
x <-data.frame(delta=(seq(min(BigZ$delta),0, .01)))
x$pred1 <- predict(ZRPs_uNeg,x)
newdata <-data.frame(delta=(seq(0,max(BigZ$delta), .01)))
newdata$pred1 <- predict(ZRPs_uPos,newdata)
newdata <-rbind(x,newdata)
polynomData<- merge(polynomData,newdata)
setnames(polynomData, "pred1", "ZRPs")
#----------------------------------------------------------------------------
#   ...And for initially unstressed Ridge wetlands
#----------------------------------------------------------------------------
x <-data.frame(delta=(seq(min(BigZ$delta),0, .01)))
x$pred1 <- predict(ZPPs_uNeg,x)
newdata <-data.frame(delta=(seq(0,max(BigZ$delta), .01)))
newdata$pred1 <- predict(ZPPs_uPos,newdata)
newdata <-rbind(x,newdata)
polynomData<- merge(polynomData,newdata)
setnames(polynomData, "pred1", "ZPPs")

#----------------------------------------------------------------------------
# Plot probability change curves for positive and negative delta theta 
#----------------------------------------------------------------------------
polynomData$delta = as.character(polynomData$delta)
longPolynom <- melt(polynomData)
longPolynom$delta <- as.numeric(longPolynom$delta)

names(longPolynom) <- c('delta','Category','Zeta')
levels(longPolynom$Category)[match("ZRPu",levels(longPolynom$Category))] <- "Ridge Adverse Chg"
levels(longPolynom$Category)[match("ZRPs",levels(longPolynom$Category))] <- "Ridge Beneficial Chg"
levels(longPolynom$Category)[match("ZPPu",levels(longPolynom$Category))] <- "Plain Adverse Chg"
levels(longPolynom$Category)[match("ZPPs",levels(longPolynom$Category))] <- "Plain Beneficial Chg"
theta = expression(theta)
text4Title<-paste0("Population-weighted Average Probability of Change\n",
                   "as a Result of an Imposed Change in Hydrologic Index(",expression(theta),")")
# longPolynom[longPolynom$Zeta < 0,]$Zeta <- 0
# longPolynom[longPolynom$Zeta > 1,]$Zeta <- 1
for (cat in levels(longPolynom$Category)){
  if (length(which(longPolynom[longPolynom$Category == cat & longPolynom$delta <= 0.00 ,]$Zeta> .999))>0) {
    cat(paste(cat, 'Zeta > .9999 \n'))
    longPolynom[longPolynom$Category == cat & 
                  longPolynom$delta <0.0 &
                  longPolynom$delta <=  max(longPolynom[longPolynom$Category == cat & 
                                                         longPolynom$Zeta > .999 & 
                                                         longPolynom$delta <0,]$delta,na.rm = T)  ,]$Zeta <- .99999999999999
    
    
  }  
  if (length(which(longPolynom[longPolynom$Category == cat & longPolynom$delta <= 0.00 ,]$Zeta < .00000001 ))>0) {
    cat(paste(cat, 'Zeta < .00000001 \n'))
    longPolynom[longPolynom$Category == cat & 
                  longPolynom$Zeta < .00000001 & 
                  longPolynom$delta <=0.0 &
                  longPolynom$delta >=  min(longPolynom[longPolynom$Category == cat & 
                                                          longPolynom$Zeta < .00000001 & 
                                                          longPolynom$delta <=0.0,]$delta,na.rm = T)  ,]$Zeta <- .00000001  
  }
  
  if (length(which(longPolynom[longPolynom$Category == cat & longPolynom$delta >= 0.00 ,]$Zeta> .999))>0) {
    cat(paste(cat, 'Zeta > .9999 \n'))
    longPolynom[longPolynom$Category == cat & 
                  longPolynom$Zeta > .999 &
                  longPolynom$delta >= 0.0 &
                  longPolynom$delta >  min(longPolynom[longPolynom$Category == cat & 
                                                         longPolynom$Zeta > .999 & 
                                                         longPolynom$delta >0,]$delta,na.rm = T)  ,]$Zeta <- .99999999999999
    
    
  }  
  if (length(which(longPolynom[longPolynom$Category == cat & longPolynom$delta >= 0.00 ,]$Zeta < .00000001 ))>0) {
    cat(paste(cat, 'Zeta < .00000001 \n'))
    longPolynom[longPolynom$Category == cat & 
                  longPolynom$Zeta < .00000001 & 
                  longPolynom$delta >=0.0 &
                  longPolynom$delta <=  min(longPolynom[longPolynom$Category == cat & 
                                                          longPolynom$Zeta < .00000001 & 
                                                          longPolynom$delta >=0.0,]$delta,na.rm = T)  ,]$Zeta <- .00000001  
  }
  
}

longPolynom[longPolynom$Zeta <0,]$Zeta<- 0.000000001
# longPolynom[longPolynom$delta < max(longPolynom[longPolynom$Zeta > 1 &
#                                                   longPolynom$delta <0,]$delta) & 
#              longPolynom$Zeta > 1 & longPolynom$delta <0 ,]$Zeta <- .99999999999999

ggplot(data=longPolynom, aes(x=delta, y=Zeta, color=Category)) + 
  geom_line(size=2) +  
  xlab(expression(paste("Change in Hydrologic Index ", Delta, theta, " feet"))) +
  theme(legend.position="bottom") +
  scale_x_continuous(breaks = c(seq(-21,15,3))) +
  labs(title =expression(atop("Population-weighted Average Probability of Change" ,
                         paste("as a Result of an Imposed Change in Hydrologic Index (",{Delta*theta},")"))))

zetaModels=list(ZRPu_sNeg=ZRPu_sNeg,ZRPu_sPos=ZRPu_sPos,
                ZPPu_sNeg=ZPPu_sNeg,ZPPu_sPos=ZPPu_sPos,
                ZRPs_uNeg=ZRPs_uNeg,ZRPs_uPos=ZRPs_uPos, 
                ZPPs_uNeg=ZPPs_uNeg,ZPPs_uPos=ZPPs_uPos)

workdir= "Y:/proj/CFWI_WetlandStress/Update2018"
saveRDS(zetaModels, paste0(workdir,"/zetaModels.RDS"))

write.csv(file=paste0(workdir,'/polynomData.csv'),polynomData,row.names=FALSE)

write.csv(file=paste0(workdir,'/Zetas.csv'),zetas,row.names=FALSE)
write.csv(file=paste0(workdir,'/ZetasMelt.csv'),zetaMelt)
write.csv(file=paste0(workdir,'/Wetlands.csv'),Wetlands)

wideTheta <- dcast(thetas,EMT_ID~rank,value.var='theta',mean)
thetaEval <- merge(wideTheta,Class1P80[,c(1,3,4,5,11)], by.x='EMT_ID', by.y = "CFCA/EMT ID")
write.csv(file=paste0(workdir,'/thetas4Eval.csv'),thetaEval)
